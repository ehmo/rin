# Scratch Pad

## Session Log

### Session 1 - 2026-02-13
- Query summary: Copy `AGENTS.md` from `~/Work/ai/vault`, remove instructions not usable for this workspace, and implement a repo-local scratchpad.
- Approach: Reviewed source `AGENTS.md`, validated this folder is not a git repo, created a trimmed local `AGENTS.md`, and initialized this scratch pad.
- Errors: None.
- Corrections: Removed monorepo-specific sections (subprojects, beads workflow, push/build requirements) because they do not apply here.
- Key learnings: This workspace is a lightweight local folder for file tasks; instructions should stay minimal and local-scope.

### Session 2 - 2026-02-13
- Query summary: Analyze both Claude transcript markdown files to reconstruct the intended product; import PMF guide and convert it into an actionable LLM evaluation document.
- Approach: Parsed both transcript files for algorithm/product decisions, extracted architecture and UX constraints, copied `The PMF Playbook.txt` into repo, and authored two design docs: `PROJECT_SYNTHESIS.md` and `PMF_AGENT_EVALUATION.md`.
- Errors: None.
- Corrections: Clarified that this is a design/product session with no code implementation.
- Key learnings: The strongest product direction is a contact-graph network with three ranking scopes (local/regional/global), immutable raw ingestion + reversible canonicalization, and stable user-facing rank cadence.

### Session 3 - 2026-02-13
- Query summary: Ingest and analyze a large set of historical notes/links for project relevance; store all source material under `/resources`.
- Approach: Created `resources/`, stored raw notes and link manifest, archived each URL to `resources/raw/` (using `fxtwitter` mapping for X/Twitter), produced one-by-one evaluation in `resources/analysis_master.md`, and generated an actionable intake in `resources/actionable_intake.md`.
- Errors: Initial bulk fetch commands stalled due long-running curl jobs; resolved by killing orphan jobs and rerunning with hard timeouts and deterministic mapping.
- Corrections: Re-fetched failed Google Slides link via alternate export URL and regenerated final fetch manifest.
- Key learnings: Social/friend-CRM demand signals are consistent across sources; strongest immediate value is discovery + relationship management + controlled reachability, not generic feed mechanics.

### Session 4 - 2026-02-13
- Query summary: Ingest replacement PDF for failed ChatGPT share and confirm/extract tweet media assets (images/videos).
- Approach: Copied and extracted `Social Circles Algorithm Insights.pdf` to text, summarized it in `resources/036_social_circles_insights_summary.md`, then built enriched tweet media extraction via `fxtwitter` OG metadata, downloading assets to `resources/media/images` and `resources/media/videos`.
- Errors: None blocking; some tweets expose only profile-avatar media in OG tags.
- Corrections: Added clear classification (`content_media` vs `profile_avatar`) and summary in `resources/media_summary.md` to avoid confusing low-value assets with real content media.
- Key learnings: We can reliably recover a useful subset of tweet media including direct MP4s from OG metadata; media quality should be explicitly classified before using it for product inspiration.

### Session 5 - 2026-02-13
- Query summary: Run full analysis across all collected resources and continue product-design task.
- Approach: Consolidated all text + media signals into `DESIGN_DECISION_MEMO_V1.md` with refined direction, v1 scope boundary, ranking/distance policy, and immediate design work queue.
- Errors: None.
- Corrections: Elevated media-derived references only when they map to concrete product mechanisms (access control UI, circle color interaction, map utility).
- Key learnings: The strongest validated wedge is friend CRM + controlled reachability + graph intelligence; defer global leaderboard/monetization complexity until trust and local utility are proven.

### Session 6 - 2026-02-13
- Query summary: Build a step-by-step user journey plan covering user experience, system behavior, and backend flow.
- Approach: Authored `USER_JOURNEY_PLAN.md` with end-to-end flows: onboarding, source verification, ingestion/dedup, circles/policies, first magic moment, ongoing loops, reachability, security/recovery, failure states, event contracts, and KPI mapping.
- Errors: None.
- Corrections: Explicitly separated official vs provisional scoring states to reduce UX volatility risk.
- Key learnings: Journey-first modeling clarifies dependencies faster than feature lists and exposes required backend events early.

### Session 7 - 2026-02-13
- Query summary: Integrate new founder notes into the user journey and make them directly reviewable while reading journey docs.
- Approach: Rewrote `USER_JOURNEY_PLAN.md` to phone-first identity and added username economics, multi-account channels, two-level dedup/privacy model, premium “how am I stored” flow, and phased 1→4 product roadmap. Updated `DESIGN_DECISION_MEMO_V1.md` and added `NOTES_TO_JOURNEY_MAPPING.md`.
- Errors: None.
- Corrections: Replaced earlier email-first assumptions with phone-first source of truth.
- Key learnings: Mapping raw founder notes to exact journey steps reduces ambiguity and reveals policy dependencies early (identity, privacy, monetization, circle governance).

### Session 8 - 2026-02-13
- Query summary: Start ranking workstream with explicit Rin Score component weights.
- Approach: Authored `RIN_SCORE_V1.md` with 0-100 formula, component weights, anti-gaming rules, explainability model, and calibration plan; linked it in journey and decision docs.
- Errors: None.
- Corrections: Turned broad “strength over size” requirement into concrete weighted components.
- Key learnings: Score systems need explicit versioning and stable release cadence to preserve user trust.

### Session 9 - 2026-02-13
- Query summary: Resolve ambiguity in circle weighting semantics and trust-penalty triggers.
- Approach: Updated `RIN_SCORE_V1.md` to decouple score weights from circle names by using internal intimacy tiers; removed unverified-channel penalty trigger because ingestion is verified-only.
- Errors: None.
- Corrections: Clarified trust penalties to use disputes/abuse/account-integrity events only.
- Key learnings: Scoring logic should rely on system metadata and verified event signals, not user-generated naming semantics.

### Session 10 - 2026-02-13
- Query summary: Remove extra user burden from scoring model after feedback on circle complexity.
- Approach: Revised `RIN_SCORE_V1.md` to eliminate required tier input and switch to optional low-weight circle signal with capped uplift.
- Errors: None.
- Corrections: Replaced tier-based weighting with passive-first scoring policy.
- Key learnings: Default scoring must work well even if user never actively manages circles.

### Session 11 - 2026-02-13
- Query summary: Finalize first locked Rin Score baseline values.
- Approach: Updated `RIN_SCORE_V1.md` with locked v1.1 defaults: circle uplift cap +5%, trust penalty severity moderate (max -15), stability window 90 days, daily official cadence.
- Errors: None.
- Corrections: Added explicit “revisit after live calibration” note to preserve flexibility.
- Key learnings: Locking concrete defaults reduces ambiguity and speeds future experiment design.

### Session 12 - 2026-02-14
- Query summary: Benchmark PageRank-style scoring complexity and infrastructure sizing across four machine categories, with explicit overhead and `140 contacts/user` including unregistered contacts.
- Approach: Modeled directed edges as `users x 140`, estimated runtime memory with overhead multipliers, and compared cluster size/cost/time by machine category under distributed scaling efficiency penalties.
- Errors: None.
- Corrections: Shifted from single-node intuition to cluster-multiplied capacity and highlighted memory-bound behavior at high scale.
- Key learnings: At billion-scale, graph jobs are primarily memory/distributed-ops constrained; many small nodes are operationally expensive even when per-node cost is low.

### Session 13 - 2026-02-14
- Query summary: Re-run benchmarks with two additional memory-heavy CPU machines (`96vCPU/1433.6GiB` and `160vCPU/3844GiB`).
- Approach: Added both machine types to the same overhead model and compared memory floor node counts, monthly costs, and graph/pipeline runtimes per user scale.
- Errors: None.
- Corrections: Confirmed these two new options materially improve memory economics versus prior machine set.
- Key learnings: For memory-bound graph scoring, these two high-RAM CPU boxes provide significantly better cost/TiB and lower cluster-management burden than prior options.

### Session 14 - 2026-02-14
- Query summary: Re-run sizing and cost benchmarks for GPU machine families from Google Compute GPU docs/pricing.
- Approach: Parsed accelerator machine rows from `compute/all-pricing` HTML (with selected region in page state), extracted machine specs + hourly prices, then recomputed memory-floor cluster size and runtime/cost ranges with the same overhead model.
- Errors: None.
- Corrections: Distinguished between theoretically cheapest GPU clusters (often many small nodes) and operationally practical clusters (bounded node count).
- Key learnings: For this graph workload, GPU options are generally more expensive than memory-dense CPU options; they mainly help when minimizing wall-clock is worth a large cost premium.

### Session 15 - 2026-02-14
- Query summary: Constrain architecture exploration to open-source-only systems and optimize for single-operator simplicity.
- Approach: Revalidated database and pipeline candidates by licensing and operational complexity, and prepared an OSS-only shortlist with include/exclude guidance.
- Errors: None.
- Corrections: Excluded source-available/closed options from the recommended path when strict OSS is required.
- Key learnings: A minimal long-lived architecture for this project should keep only one transactional DB plus one open lakehouse layer as always-on systems.

### Session 16 - 2026-02-14
- Query summary: Produce high-level end-to-end OSS architecture plan (app-first) including search, queueing, compute/lake overlap, and benchmark operations at 10M/100M/1B/10B records.
- Approach: Authored `ARCHITECTURE_PLAN_OSS_V1.md` with system map, data flows, overlap rules, scale runbooks, and record-based workload/compute/memory benchmark assumptions.
- Errors: None.
- Corrections: Explicitly separated record-scale benchmark from earlier user-scale benchmark to avoid scope confusion.
- Key learnings: With clean OLTP/event/lake boundaries, the same architecture can scale without major rewrites; most complexity is operational policy, not core component count.

### Session 17 - 2026-02-14
- Query summary: Continue to full DB-first system design with service/runtime constraints (Go/Fiber, zerolog, Sentry, NATS), add user classes (single/shadow/business+employee), run large scenario simulations, and iterate architecture until unresolved items remain after two passes.
- Approach: Authored `SYSTEM_ARCHITECTURE_DB_FIRST_V2.md` and `SIMULATION_RESULTS_V1.md`; executed 3 Monte Carlo programs (3,900 total iterations) including forced extremes (1M-contact + 5-contact users), baseline-vs-mitigated stress model, and class-expansion risk model.
- Errors: None.
- Corrections: Added explicit unresolved-risk section only after second iteration pass, per request.
- Key learnings: Partition bucketing + owner ingest throttling resolves DB hotspot failures, but verification/dispute throughput and shadow-profile abuse policy remain dominant unresolved constraints at extreme scale.

### Session 18 - 2026-02-14
- Query summary: Draft a concrete dispute operating playbook covering technical workflow, UX flow, case taxonomy, SLAs, ranking side effects, and retention defaults.
- Approach: Authored `DISPUTE_PLAYBOOK_V1.md` with six dispute case classes, dual state machines, severity-based automatic safeguards, event contract list, and unresolved decision checklist.
- Errors: None.
- Corrections: Explicitly encoded the policy that shadow profiles are excluded from ranking.
- Key learnings: Dispute handling needs explicit role/state contracts before implementation; otherwise security, trust scoring, and user support behavior will diverge.

### Session 19 - 2026-02-14
- Query summary: Produce implementation-grade ownership state machine contract.
- Approach: Authored `OWNERSHIP_STATE_MACHINE_SPEC_V1.md` with canonical states, allowed/forbidden transitions, preconditions, timers/holds, concurrency/idempotency rules, deterministic side effects, and error-code contract.
- Errors: None.
- Corrections: Added explicit constraints for shadow profiles (no direct channel ownership) and business authority boundaries.
- Key learnings: Strict transition contracts materially reduce security ambiguity and replay bugs in dispute-heavy systems.

### Session 20 - 2026-02-14
- Query summary: Produce event contract catalog for NATS JetStream aligned with ownership/dispute architecture.
- Approach: Authored `EVENT_CONTRACT_CATALOG_V1.md` with global envelope, subject taxonomy, core event list, stream partitioning, ordering/idempotency/retry/replay contracts, and governance process.
- Errors: None.
- Corrections: Included explicit shadow profile rank-exclusion and discoverability metadata requirement in event privacy rules.
- Key learnings: Stable event envelopes and per-aggregate ordering keys are critical to keeping replay, dispute handling, and scoring projections consistent.

### Session 21 - 2026-02-14
- Query summary: Create profile class behavior contract for single/shadow/business/employee identities.
- Approach: Authored `PROFILE_CLASS_CONTRACT_V1.md` with class definitions, capability matrix, discoverability defaults, ranking inclusion rules, class transitions, delegation constraints, and edge-case handling.
- Errors: None.
- Corrections: Explicitly set shadow profiles to non-discoverable-by-default and non-ranked.
- Key learnings: Class contracts must be explicit early to avoid search/ranking abuse and authority ambiguity in business/employee flows.

### Session 22 - 2026-02-14
- Query summary: Create scale guardrail contract with concrete transition triggers and rollback criteria.
- Approach: Authored `SCALE_GUARDRAIL_CONTRACT_V1.md` with mode definitions, SLO thresholds, trigger matrix, transition playbooks (PG->Citus, PG FTS->external search), and edge-case guardrails.
- Errors: None.
- Corrections: Bound guardrails to record-based scale bands to stay consistent with prior benchmark framing.
- Key learnings: Explicit scale trigger contracts reduce costly premature migrations and provide clear escalation paths during contention spikes.

### Session 23 - 2026-02-14
- Query summary: Build integrated operations runbook that stitches architecture and all contracts into daily operations, incident handling, and migration execution.
- Approach: Authored `SYSTEM_RUNBOOK_V1.md` with daily rhythm checklists, incident class playbooks, migration-day procedures, replay/recovery flow, and governance cadence.
- Errors: None.
- Corrections: Added explicit profile-class enforcement checks (shadow discoverability/ranking) into the runbook’s P1 incident criteria.
- Key learnings: Contract docs become actionable only when combined into one operational sequence with clear escalation and rollback rules.

### Session 24 - 2026-02-14
- Query summary: Define high-level data ownership boundaries per service without introducing physical table design.
- Approach: Authored `DATA_MODEL_BOUNDARIES_V1.md` with domain aggregate ownership, service write/read authority matrix, cross-domain change rules, consistency model, and boundary compliance checks.
- Errors: None.
- Corrections: Reinforced shadow class hard boundaries (no channel ownership, no ranking inclusion) as P1 boundary invariants.
- Key learnings: Clear ownership boundaries prevent “shortcut writes” and are essential for replay-safe event-driven systems.

### Session 25 - 2026-02-14
- Query summary: Build a master index to unify all architecture artifacts and define a practical reading/execution order.
- Approach: Authored `ARCHITECTURE_MASTER_INDEX.md` with phased reading path, dependency graph, locked decisions, open decision list, and architecture freeze sequencing.
- Errors: None.
- Corrections: Consolidated scattered “next steps” into one freeze-oriented sequence to prevent planning drift.
- Key learnings: A master index reduces context-switch cost and helps keep implementation gated on explicit contract freeze.

### Session 26 - 2026-02-14
- Query summary: Restructure repository into a long-lived monorepo layout covering future code, infra, design, and existing documentation/research.
- Approach: Created top-level monorepo folders (`apps`, `packages`, `infra`, `docs`, `design`, `scripts`), moved existing artifacts into functional doc domains, added root and domain README files, and created `.gitkeep` placeholders for empty future code/infrastructure directories.
- Errors: None.
- Corrections: Updated architecture index links to new canonical document paths after relocation.
- Key learnings: Stable monorepo ergonomics come from clear domain boundaries and a single documentation entry point, not deep nesting.

### Session 27 - 2026-02-14
- Query summary: Add and integrate a repository-wide monorepo convention standard before code implementation starts.
- Approach: Authored `docs/architecture/MONOREPO_CONVENTIONS_V1.md`, then linked it from `README.md` and `docs/architecture/ARCHITECTURE_MASTER_INDEX.md`.
- Errors: None.
- Corrections: Expanded architecture index reading order and quick-navigation to include the conventions contract.
- Key learnings: Defining repository conventions early reduces future churn and keeps implementation aligned with architecture contracts.

## Error Tracker

- None recorded yet.

## Corrections and Preferences

- Keep instructions practical for this exact folder and avoid repo tooling assumptions (git/beads) unless introduced later.
- Maintain a concise markdown-first workflow.
- In design sessions, prioritize synthesis docs, decision frameworks, and architecture clarity over implementation details.
- When ingesting many social links, normalize X/Twitter URLs through `fxtwitter` before text extraction to improve retrieval reliability.
- For tweet media, parse OG tags from `fxtwitter` pages to retrieve actual `og:video` MP4 links when available.
- Distinguish “inspirational media” from “direct product pattern” before turning references into requirements.
- For product planning, pairing each UX step with backend events/data writes prevents hidden architecture gaps.
- Keep a live “notes-to-journey mapping” doc so evolving founder intent stays synchronized with system design artifacts.
- Ranking specs should be versioned and frozen per release cycle to prevent confusing score drift.
- For performance planning, always separate: graph-core compute time vs full pipeline time (ingest/dedup/shuffle/checkpoint/QA overhead).
- Use simulation passes to pressure-test architecture assumptions before finalizing contracts; track unresolved items only after at least two adjustment cycles.
- Keep dispute systems designed as product features (not just backend controls) because user comprehension materially affects resolution speed and safety.
- State machine contracts should be finalized before endpoint-level API design to prevent hidden transition paths and inconsistent operator behavior.
- Event contracts should be frozen alongside state machine contracts to avoid cross-service drift in side effects and replay semantics.
- Profile class contracts should be treated as first-order security/ranking inputs, not just UI metadata.
- Scale transitions should be governed by sustained indicators and rollback criteria, not single-point load spikes.
- Maintain one integrated runbook to align product-policy contracts with live operational actions during incidents and migrations.
- Keep a dedicated boundary contract so service decomposition and deployment changes do not silently alter domain ownership authority.
- Maintain a master architecture index as the canonical entry point once document count grows beyond a handful of specs.
- Keep top-level root clean (`README.md`, `AGENTS.md`, `.scratch-pad.md`) and route all evolving materials into domain folders to avoid long-term repo drift.
- Treat monorepo conventions as a first-class contract and update them alongside architecture contracts when structure/process rules change.

## Anticipated Improvements

- Add project-specific conventions if this folder grows into a codebase (tests, lint, build, release steps).
- Add naming conventions for exported/downloaded artifacts if volume increases.
- Add a decision log file for unresolved algorithm and product tradeoffs (ranking stability, pricing rollout, anti-gaming policy).
- Add a “source confidence” rubric for imported links (full text vs partial vs unavailable).
- Add a “media confidence” rubric (content media vs avatar/emoji/decorative).

## Cumulative Learnings

- Prefer scoped, minimal process docs for small local workspaces.
- Convert long strategy conversations into structured artifacts quickly to preserve intent and reduce ambiguity.
- Large link dumps are most useful after conversion into: (1) one-by-one matrix, (2) prioritized actions, (3) explicit discard list.
- Media extraction without classification creates noise; always separate substantive media from decorative/profile assets.
- User journey revisions should overwrite stale assumptions quickly (e.g., onboarding order, identity primitive) to prevent drift.
