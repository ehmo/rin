# iOS API Client and Contract Versioning V1

## 1) Purpose

Define the API client architecture for the iOS app, using ConnectRPC with Protocol Buffers for type-safe, bandwidth-efficient communication with the Go backend.

Companion docs:
- `docs/architecture/IOS_APP_ARCHITECTURE_V1.md` (module structure)
- `docs/architecture/SERVICE_IMPLEMENTATION_BLUEPRINT_V1.md` (backend service map)
- `docs/plan/outlines/02_API_SURFACE_OUTLINE_V1.md` (API contracts)

---

## 2) Wire Protocol: ConnectRPC

### 2.1 Why ConnectRPC

| Requirement | ConnectRPC | REST+JSON | Raw gRPC |
|------------|------------|-----------|----------|
| Payload size | Small (Protobuf binary) | Large (JSON text) | Small (Protobuf) |
| iOS binary size | <200KB (connect-swift) | ~0 (URLSession) | Megabytes (gRPC-Swift + SwiftNIO) |
| Type safety | Generated from .proto | Manual Codable | Generated from .proto |
| Debugging | JSON mode available | Native JSON | Hard (binary only) |
| HTTP/2 required | No (HTTP/1.1 works) | No | Yes |
| Streaming support | Yes (when needed) | No | Yes |
| Go integration | net/http handlers | Any framework | Special server |
| iOS networking | URLSession (native) | URLSession | SwiftNIO |

### 2.2 Research Basis

Top mobile apps using Protobuf for wire efficiency:
- **Uber**: gRPC+Protobuf, 45% payload reduction, 27% latency improvement.
- **LinkedIn**: Protobuf migration, 60% latency reduction on large payloads.
- **Lyft**: Company-wide Protobuf IDL adoption.
- **Signal**: REST+Protobuf for structured data.
- **WhatsApp, Snapchat, Google Maps**: All Protobuf-based.

ConnectRPC chosen as the sweet spot: Protobuf efficiency without gRPC's iOS complexity.

---

## 3) Stack

### 3.1 Server Side (Go)

- **connect-go**: Generates Go handlers from .proto files.
- Handlers are standard `net/http.Handler` — works with Fiber/Chi/stdlib.
- Supports Connect, gRPC, and gRPC-Web protocols simultaneously.

### 3.2 Client Side (Swift)

- **connect-swift**: Generates async/await Swift client code from .proto files.
- Uses `URLSession` (no SwiftNIO dependency).
- Generated mock implementations for testing.
- Supports both JSON (debugging) and binary Protobuf (production) encoding.

### 3.3 Schema Management

- `.proto` files live in `packages/proto/` (shared between Go and Swift).
- Code generation via `buf` CLI with `buf.gen.yaml` config.
- Generated code committed to repo (no build-time generation).
- CI validates proto schema changes don't break existing clients.

---

## 4) Proto File Organization

```
packages/proto/
├── buf.yaml                  # Buf project config
├── buf.gen.yaml              # Code generation config
├── rin/
│   ├── identity/v1/
│   │   └── identity.proto    # Principal, auth, account
│   ├── contacts/v1/
│   │   └── contacts.proto    # Contact CRUD, import, sync
│   ├── dedup/v1/
│   │   └── dedup.proto       # Dedup suggestions, merge
│   ├── circles/v1/
│   │   └── circles.proto     # Circle CRUD, membership, policies
│   ├── profiles/v1/
│   │   └── profiles.proto    # Profile management, shadow profiles
│   ├── score/v1/
│   │   └── score.proto       # Score retrieval, components
│   ├── search/v1/
│   │   └── search.proto      # Contact/profile search
│   ├── security/v1/
│   │   └── security.proto    # Disputes, reports, blocks
│   ├── premium/v1/
│   │   └── premium.proto     # Subscription status, features
│   └── common/v1/
│       └── common.proto      # Shared types (pagination, errors, timestamps)
```

### 4.1 Versioning

- Each service proto is versioned in its path (`v1/`, `v2/`).
- New versions created only for breaking changes.
- Non-breaking additions (new fields, new RPCs) added to existing version.
- Protobuf's field numbering guarantees backward compatibility for additive changes.

---

## 5) API Client Architecture (RinCore)

### 5.1 Client Layer

```swift
// Generated by connect-swift (simplified)
protocol ContactsServiceClientInterface {
    func listContacts(request: ListContactsRequest) async throws -> ListContactsResponse
    func getContact(request: GetContactRequest) async throws -> GetContactResponse
    func importContacts(request: ImportContactsRequest) async throws -> ImportContactsResponse
    // ... generated from .proto
}

// Also generated: mock implementation
class ContactsServiceClientMock: ContactsServiceClientInterface {
    // Stub methods for testing
}
```

### 5.2 Transport Configuration

```swift
// In RinApp (app target)
let transport = URLSessionTransport(
    baseURL: apiBaseURL,
    interceptors: [
        AuthInterceptor(),        // Injects auth token
        CorrelationInterceptor(), // Adds request ID
        IdempotencyInterceptor(), // Adds idempotency key for mutations
        RetryInterceptor(),       // Exponential backoff for transient errors
    ]
)
```

### 5.3 Interceptor Chain

| Interceptor | Responsibility |
|-------------|---------------|
| `AuthInterceptor` | Injects Bearer token from Keychain. Triggers refresh on 401. |
| `CorrelationInterceptor` | Adds `X-Request-ID` header for server-side tracing. |
| `IdempotencyInterceptor` | Adds `Idempotency-Key` header for mutation requests. |
| `RetryInterceptor` | Retries transient failures (5xx, network timeout) with exponential backoff. Max 3 retries. |
| `AnalyticsInterceptor` | Logs request duration and error rates to PostHog. |

---

## 6) Auth Flow

### 6.1 Token Management

- Auth token stored in iOS Keychain.
- Token format: JWT or opaque session token (server decides).
- `AuthInterceptor` injects token on every request.
- On 401 response: attempt token refresh. If refresh fails: clear auth state, trigger re-authentication.

### 6.2 Auth State Machine

```
Unauthenticated → Authenticating → Authenticated → Token Expired → Refreshing → Authenticated
                                                                   ↓ (refresh fails)
                                                              Unauthenticated
```

`AuthService` publishes state changes. `AppCoordinator` observes and switches between onboarding and main app.

---

## 7) Offline Queue

### 7.1 Mutation Queue

When connectivity is unavailable:
1. Mutation request serialized (Protobuf binary) with idempotency key.
2. Stored in SwiftData queue table.
3. When connectivity returns, queue replayed in order.
4. Idempotency key prevents duplicate execution on server.

### 7.2 Queue Schema

```
MutationQueueEntry
├── id: UUID
├── service: String (e.g., "contacts")
├── method: String (e.g., "updateContact")
├── payload: Data (serialized Protobuf)
├── idempotencyKey: String
├── createdAt: Date
├── retryCount: Int
├── lastError: String?
```

### 7.3 Retry Policy

- Max 5 retries per mutation.
- Exponential backoff: 1s, 2s, 4s, 8s, 16s.
- After max retries: mark as failed, surface to user.
- Queue processing paused if auth state is unauthenticated.

---

## 8) Error Handling

### 8.1 Connect Error Codes

ConnectRPC uses standard error codes (mapped from gRPC):

| Code | Meaning | Client action |
|------|---------|--------------|
| `canceled` | Request cancelled | No action |
| `invalidArgument` | Bad request data | Show validation error |
| `notFound` | Resource not found | Show not found state |
| `alreadyExists` | Duplicate | Show conflict message |
| `permissionDenied` | Not authorized | Show access denied |
| `unauthenticated` | Auth required | Trigger re-auth |
| `resourceExhausted` | Rate limited | Backoff and retry |
| `internal` | Server error | Show generic error, log to Sentry |
| `unavailable` | Service down | Queue or retry |

### 8.2 Error Presentation

- ViewModel maps Connect errors to user-facing messages.
- Network unavailable: show offline banner (not error).
- Server errors: generic "Something went wrong" with retry button.
- Validation errors: inline field-level feedback.

---

## 9) Performance

### 9.1 Request Optimization

- Protobuf binary encoding by default (JSON available for debugging).
- HTTP/2 connection multiplexing when available.
- Response compression (gzip/zstd).
- Pagination for list endpoints (cursor-based).

### 9.2 Benchmarks (Expected)

For a 500-contact list response:
- JSON: ~50-80KB → Protobuf: ~20-35KB (56% smaller).
- On 3G (1 Mbps): 400ms → 160ms transfer time.
- On 2G (250 Kbps): 2.5s → 1s transfer time.

---

## 10) Testing

### 10.1 Generated Mocks

connect-swift generates mock implementations conforming to the same protocol as real clients. Tests inject mocks — no network calls in unit tests.

### 10.2 Contract Tests

- CI runs proto compatibility checks (buf breaking) against the last release.
- Integration tests call staging server to verify real RPC behavior.

---

## 11) Open Decisions

1. Whether to use `buf` managed plugins or local protoc installation for code generation.
2. Whether to support JSON encoding toggle for debug builds (useful but adds code paths).
3. Whether to implement client-side request deduplication (multiple views requesting same data).
4. Whether to add request cancellation for navigation-driven lifecycle (pop screen → cancel in-flight).
5. Whether to use ConnectRPC streaming for real-time features (score updates, sync progress) or separate WebSocket.
